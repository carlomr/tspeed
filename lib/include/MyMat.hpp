/**
 * @file MyMat.hpp
 * @brief Header file for the matrices specialized for the Discontinuous Galerkin method
 * @author Carlo Marcati
 * @date 2013-09-08
 */
/* This program is free software: you can redistribute it and/or modify 
 *  it under the terms of the GNU General Public License as published by 
 *  the Free Software Foundation, either version 3 of the License, or 
 *  (at your option) any later version. 
 *  
 *  This program is distributed in the hope that it will be useful, 
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of 
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 *  GNU General Public License for more details. 
 *  
 *  You should have received a copy of the GNU General Public License 
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#ifndef __MYMAT_HPP__
#define __MYMAT_HPP__ 1
#include<Eigen/Dense>
#include<vector>
#include"Mesh.hpp"
#include<fstream>
namespace Tspeed{
    /**
     * @brief Base monodimensional matrix class
     */
    class BaseMat
    {
	public:
	    BaseMat();
	    BaseMat(Mesh_ptr , unsigned int nln) ;
	    /**
	     * @brief Get sub-block generated by integration on elements i and j (\f$ \neq 0 \f$ if they are neighbors) (const version)
	     *
	     * @param i,j the indices of the triangles
	     *
	     * @return The sub-block
	     */
	    Eigen::MatrixXd const & block(unsigned int i, unsigned int j)const;
	    /**
	     * @brief Get sub-block generated by integration on elements i and j (\f$ \neq 0 \f$ if they are neighbors) (non-const version)
	     *
	     * @param i,j the indices of the triangles
	     *
	     * @return The sub-block
	     */
	    Eigen::MatrixXd & block(unsigned int i, unsigned int j);
	    /**
	     * @brief Set sub-block generated by integration on elements i and j (\f$ \neq 0 \f$ if they are neighbors) (const version)
	     *
	     * @param i,j the indices of the triangles
	     * @param M the matrix assigned to the sub-block
	     *
	     */
	    void setblock(unsigned int i, unsigned int j, Eigen::MatrixXd const & M);
	    BaseMat(BaseMat const&) ;
	    virtual ~BaseMat() = default;

	    /**
	     * @brief Get number of rows of the matrix
	     *
	     * @return The number of rows 
	     */
	    unsigned int nr()const{return M_nr;};
	    /**
	     * @brief Get row indices of the matrix
	     *
	     */
	    std::vector<unsigned int> const & rowInd()const{return M_r;};
	    /**
	     * @brief Get column indices of the matrix
	     *
	     */
	    std::vector<unsigned int> const & colInd()const{return M_c;};
	    /**
	     * @brief Set row indices of the matrix
	     *
	     */
	    void set_rowInd(std::vector<unsigned int>const & v){M_r=v;};
	    /**
	     * @brief Set column indices of the matrix
	     *
	     */
	    void set_colInd(std::vector<unsigned int>const & v){M_c=v;};
	    /**
	     * @brief Get a vector with all the sub-blocks (const version)
	     *
	     */
	    std::vector<Eigen::MatrixXd> const & elem()const{return M_m;};
	    /**
	     * @brief Get a vector with all the sub-blocks (non-const version)
	     *
	     */
	    std::vector<Eigen::MatrixXd> & elem(){return M_m;};
	    /**
	     * @brief Get sub-block linearly indexed by i
	     *
	     * @param i the linear index of the sub-block
	     *
	     */
	    Eigen::MatrixXd const & elem(int i)const{return M_m[i];};
	    /**
	     * @brief Get the number of sub-blocks
	     *
	     */
	    unsigned int size()const{return M_m.size();};
	    /**
	     * @brief Multiplication by a vector
	     *
	     * @param[in] x term to be multiplied
	     * @param[out] out result of the multiplication 
	     */
	    void vecMult(Eigen::VectorXd const & x, Eigen::VectorXd & out)const;
	protected:
	    unsigned int M_nr;
	    unsigned int M_nc;
	    unsigned int M_nln;
	    std::vector<Eigen::MatrixXd> M_m;
	    std::vector<unsigned int> M_r;
	    std::vector<unsigned int> M_c;

    };
    /**
     * @brief Block diagonal monodimensional matrix (monodimensional block of mass and stress-strain matrices)
     */
    class MyMatBlockDiag : public BaseMat 
    {
	public:
	    MyMatBlockDiag():BaseMat(){};
	    /**
	     * @brief Contructor from the mesh
	     *
	     * @param Th pointer to the mesh
	     * @param nln number of degrees of freedom per element
	     */
	    MyMatBlockDiag(Mesh_ptr Th , unsigned int nln);
	    MyMatBlockDiag(MyMatBlockDiag&&) = default;
	    MyMatBlockDiag(MyMatBlockDiag const&) = default;
	    MyMatBlockDiag & operator=(MyMatBlockDiag&&) = default;
	    MyMatBlockDiag & operator=(MyMatBlockDiag const&) = default;
	    virtual ~MyMatBlockDiag()noexcept(true) = default;
    };

    /**
     * @brief Block Matrix (monodimensial blocks of stability and interelement matrices)
     */
    class MyMat : public BaseMat
    {
	public:

	    MyMat():BaseMat(){};
	    /**
	     * @brief Contructor from the mesh
	     *
	     * @param Th pointer to the mesh
	     * @param nln number of degrees of freedom per element
	     */
	    MyMat(Mesh_ptr , unsigned int nln);
	    MyMat(MyMat&&) = default;
	    MyMat(MyMat const&) ;
	    MyMat&operator=(MyMat&&) = default;
	    MyMat&operator=(MyMat const&) = default;
	    virtual ~MyMat()noexcept(true) = default;

	    /**
	     * @brief sum with self transposed
	     */
	    void symmetrize();
	    /**
	     * @brief Sum with ot transposed	
	     *
	     * @param ot The const matrix to be transposed and summed to current
	     */
	    void sumtranspose(MyMat const & ot);
	    MyMat operator+=(MyMat const & );
	    MyMat operator+=(MyMatBlockDiag const & );
	    MyMat operator*(double const & )const;
    };
    MyMat operator*(double const & c, MyMat const & M);
    Eigen::VectorXd operator*(MyMat const &,Eigen::VectorXd const &);
    Eigen::VectorXd operator*(MyMatBlockDiag const &,Eigen::VectorXd const &);
    MyMat operator+(MyMat a, MyMat const &b);
    MyMat operator+(MyMat a, MyMatBlockDiag const &b);
    /**
     * @brief Multidimensional matrix
     *
     * @tparam T type of the monodimensional blocks
     */
    template<typename T>
	class MyMatMultiDim
    {
	public:
	    MyMatMultiDim() = default;
	    virtual ~MyMatMultiDim() = default;
	    MyMatMultiDim(Mesh_ptr , unsigned int nln);
	    /**
	     * @brief Return monodimensimenial block (i,j)
	     *
	     * @param i "row" index
	     * @param j "column" index
	     *
	     * @return A monodimensional matrix of type
	     */
	    T & component(int i, int j){return M_mat[i*2+j];};
	    /**
	     * @brief Return monodimensimenial block (i,j) (const version)
	     *
	     * @param i "row" index
	     * @param j "column" index
	     *
	     * @return A monodimensional matrix of type
	     */
	    T const & component(int i, int j)const{return M_mat[i*2+j];};
	    /**
	     * @brief Sum matrix to self transposed
	     */
	    void symmetrize();
	    /**
	     * @brief Multiplication by a vector
	     *
	     * @param[in] x term to be multiplied
	     * @param[out] out result of the multiplication 
	     */
	    void vecMult(Eigen::VectorXd const & x, Eigen::VectorXd & out)const;
	    MyMatMultiDim(MyMatMultiDim&a){for (int i:{0,1,2,3}){this->M_mat[i] = a.M_mat[i];};};
	    MyMatMultiDim&operator=(MyMatMultiDim&&) = default;
	    Eigen::VectorXd operator*(Eigen::VectorXd const &v)const;
	    //template<>
	    friend MyMatMultiDim<MyMat>  operator+(MyMatMultiDim<MyMat> const &a , MyMatMultiDim<MyMat> const& b);
	    friend MyMatMultiDim<MyMat>  operator+(MyMatMultiDim<MyMat> const &a , MyMatMultiDim<MyMatBlockDiag> const& b);
	    friend MyMatMultiDim<T> operator*(double const & x, MyMatMultiDim<T> const & A){MyMatMultiDim out; for(int i:{0,1,2,3}) out.M_mat[i] = x*A.M_mat[i]; return out;};
	private:
	    std::array<T,4> M_mat;
    };
    /**
     * @brief Matrix class for matrices where only the diagonal monodimensional matrices are non zero (i.e. the mass matrix)
     *
     * @tparam T
     */
    template<typename T>
	class MyMatMultiDimBlockDiag
    {
	public:
	    MyMatMultiDimBlockDiag() = default;
	    virtual ~MyMatMultiDimBlockDiag() = default;
	    MyMatMultiDimBlockDiag(Mesh_ptr , unsigned int nln);
	    /**
	     * @brief Get monodimensional component (0,0) if i=0 or (1,1) if i=1:
	     *
	     * @param i Select component
	     *
	     * @return Monodimensional matrix of type T
	     */
	    T & component(int i){return M_mat[i];};
	    /**
	     * @brief Get monodimensional component (0,0) if i=0 or (1,1) if i=1 (const version)
	     *
	     * @param i Select component
	     *
	     * @return Monodimensional matrix of type T
	     */
	    T const & component(int i)const{return M_mat[i];};
	    /**
	     * @brief Multiplication by a vector
	     *
	     * @param[in] x term to be multiplied
	     * @param[out] out result of the multiplication 
	     */
	    void vecMult(Eigen::VectorXd const & x, Eigen::VectorXd & out)const;
	    MyMatMultiDimBlockDiag(MyMatMultiDimBlockDiag&&) = default;
	    //MyMatMultiDimBlockDiag(MyMatMultiDimBlockDiag&) = default;
	    MyMatMultiDimBlockDiag&operator=(MyMatMultiDimBlockDiag&&) = default;
	    /**
	     * @brief Get total number of rows
	     *
	     */
	    unsigned int nr()const{return M_mat[0].nr()+M_mat[1].nr();};
	    //friend MyMatMultiDimBlockDiag<MyMat> & operator+(MyMatMultiDimBlockDiag<MyMat> const &a , MyMatMultiDimBlockDiag<MyMatBlockDiag> const& b);
	    Eigen::VectorXd operator*(Eigen::VectorXd const &v)const;
	    friend MyMatMultiDimBlockDiag const & operator*(double const & x, MyMatMultiDimBlockDiag const & A){MyMatMultiDimBlockDiag* out = new MyMatMultiDimBlockDiag(); for(int i:{0,1,2,3}) out->M_mat[i] = x*A.M_mat[i]; return *out;};
	private:
	    std::array<T,2> M_mat;
    };
    template<typename T>
	MyMatMultiDimBlockDiag<T>::MyMatMultiDimBlockDiag(Mesh_ptr  m, unsigned int nln)
    {
	for(int i:{ 0,1 })
	{
	    M_mat[i] = T(m, nln);
	}
    }

    template<typename T>
    MyMatMultiDim<T>::MyMatMultiDim(Mesh_ptr  m, unsigned int nln)
    {
	for(int i:{ 0,1,2,3 })
	{
	    M_mat[i] = T(m, nln);
	}
    }
    template <typename T>
    void MyMatMultiDimBlockDiag<T>::vecMult(Eigen::VectorXd const & x, Eigen::VectorXd & out)const
    {
	assert(x.size()==M_mat[0].nr()*2);
	out.segment(0,M_mat[0].nr()) = M_mat[0] * x.segment(0,M_mat[0].nr());
	out.segment(M_mat[0].nr(),M_mat[0].nr()) = M_mat[1]* x.segment(M_mat[0].nr(),M_mat[0].nr());
    }
template <typename T>
    void MyMatMultiDim<T>::vecMult(Eigen::VectorXd const & x, Eigen::VectorXd & out)const
    {
	assert(x.size()==M_mat[0].nr()*2);
	int hS = M_mat[0].nr();
	out.segment(0,hS) = M_mat[0] * x.segment(0,hS)+M_mat[1]* x.segment(hS,hS);
	out.segment(hS,hS) = M_mat[2] * x.segment(0,hS)+M_mat[3]* x.segment(hS,hS);

    }
    template<typename T>
    void MyMatMultiDim<T>::symmetrize()
    {
	M_mat[0].symmetrize();
	M_mat[3].symmetrize();
	T temp = M_mat[1];
	M_mat[1].sumtranspose(M_mat[2]);
	M_mat[2].sumtranspose(temp); //TODO:cosi fa schifo
    }
    template<typename T>
    Eigen::VectorXd MyMatMultiDim<T>::operator*( Eigen::VectorXd const &v)const
    {
	Eigen::VectorXd  out(v.size());
	this->vecMult(v,out);
	return out;
    }
    template<typename T>
    Eigen::VectorXd MyMatMultiDimBlockDiag<T>::operator*(Eigen::VectorXd const &v)const
    {
	Eigen::VectorXd  out(v.size());
	this->vecMult(v,out);
	return out;
    }
    
}
#endif
